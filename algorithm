public static int calcularCreatividad(int n, int[] P) {
		int creatividad = 0;
		for (int pos = 0; pos < 5; pos++) {
			int digit = (n / (int) Math.pow(10, pos)) % 10;
			if (digit == 3) creatividad += P[pos];
			else if (digit == 6) creatividad += 2 * P[pos];
			else if (digit == 9) creatividad += 3 * P[pos];
		}
		return creatividad;
	}

	// Genera candidatos creativos
	public static List<Integer> generarCandidatosCreativos(int n, int[] P) {
		List<Integer> candidatos = new ArrayList<>();
		candidatos.add(0); // incluir el 0 como candidato v√°lido
		for (int i = 1; i <= n; i++) {
			if (calcularCreatividad(i, P) > 0) candidatos.add(i);
		}
		return candidatos;
	}

	// Knapsack O(nk) usando solo candidatos creativos
	public static int knapsackOKN(int n, int k, int[] P) {
		List<Integer> candList = generarCandidatosCreativos(n, P);

		int[] creatividad = new int[n + 1];
		for (int i = 0; i <= n; i++) creatividad[i] = calcularCreatividad(i, P);


		int[] dp = new int[n + 1];
		Arrays.fill(dp, -1);
		dp[0] = 0;
		for (int celda = 1; celda <= k; celda++) {
			int[] next = new int[n + 1];
			Arrays.fill(next, -1);
			for (int i = 0; i <= n; i++) {
				if (dp[i] == -1) continue;
				for (int cand : candList) {
					if (i + cand <= n) {
						int c = creatividad[cand];
						next[i + cand] = Math.max(next[i + cand], dp[i] + c);
					} else break;
				}
			}
			if (Arrays.equals(dp, next)) break;
			dp = next;
		}
		int maxCreatividad = 0;
		for (int i = 0; i <= n; i++) {
			maxCreatividad = Math.max(maxCreatividad, dp[i]);
		}
		return maxCreatividad;
	}